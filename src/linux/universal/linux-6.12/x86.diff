Index: init/main.c
===================================================================
--- init/main.c	(revision 55864)
+++ init/main.c	(revision 55863)
@@ -144,7 +144,6 @@
 char __initdata boot_command_line[COMMAND_LINE_SIZE];
 /* Untouched saved command line (eg. for /proc) */
 char *saved_command_line __ro_after_init;
-EXPORT_SYMBOL(saved_command_line);
 unsigned int saved_command_line_len __ro_after_init;
 /* Command line for parameter parsing */
 static char *static_command_line;
@@ -946,6 +945,8 @@
 	}
 #endif
 
+	/* parameters may set static keys */
+	jump_label_init();
 
 	/* Show bootloader's original command line for reference */
 	if (IS_ENABLED(CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_MANGLE) && of_chosen) {
@@ -957,9 +958,6 @@
 			pr_notice("Bootloader command line not present\n");
 	}
 
-	/* parameters may set static keys */
-	jump_label_init();
-
 	parse_early_param();
 	after_dashes = parse_args("Booting kernel",
 				  static_command_line, __start___param,
@@ -1411,7 +1409,7 @@
 		pr_debug("    %s\n", *p);
 	return kernel_execve(init_filename, argv_init, envp_init);
 }
-#if 0
+
 static int try_to_run_init_process(const char *init_filename)
 {
 	int ret;
@@ -1425,7 +1423,6 @@
 
 	return ret;
 }
-#endif
 
 static noinline void __init kernel_init_freeable(void);
 
@@ -1533,7 +1530,6 @@
 	 * The Bourne shell can be used instead of init if we are
 	 * trying to recover a really broken machine.
 	 */
-#if 0
 	if (execute_command) {
 		ret = run_init_process(execute_command);
 		if (!ret)
@@ -1556,9 +1552,6 @@
 	    !try_to_run_init_process("/bin/init") ||
 	    !try_to_run_init_process("/bin/sh"))
 		return 0;
-#endif
-	if (!run_init_process("/sbin/init"))
- 		return 0;
 
 	panic("No working init found.  Try passing init= option to kernel. "
 	      "See Linux Documentation/admin-guide/init.rst for guidance.");
@@ -1570,7 +1563,7 @@
 	struct file *file = filp_open("/dev/console", O_RDWR, 0);
 
 	if (IS_ERR(file)) {
-		printk(KERN_WARNING "Please be patient, while System loads ...\n");
+		pr_err("Warning: unable to open an initial console.\n");
 		return;
 	}
 	init_dup(file);
Index: init/Kconfig
===================================================================
--- init/Kconfig	(revision 55864)
+++ init/Kconfig	(revision 55863)
@@ -148,14 +148,6 @@
 	  Maximum of each of the number of arguments and environment
 	  variables passed to init from the kernel command line.
 
-config CROSS_COMPILE
-	string "Cross-compiler tool prefix"
-	help
-	  Same as running 'make CROSS_COMPILE=prefix-' but stored for
-	  default make runs in this kernel build directory.  You don't
-	  need to set this unless you want the configured kernel build
-	  directory to select the cross-compiler automatically.
-
 config COMPILE_TEST
 	bool "Compile also drivers which will not load"
 	depends on HAS_IOMEM
@@ -1378,13 +1370,6 @@
 	prompt "Compiler optimization level"
 	default CC_OPTIMIZE_FOR_PERFORMANCE
 
-config CC_OPTIMIZE_FOR_PERFORMANCE_O3
-	bool "Optimize for performance O3"
-	help
-	  This is the default optimization level for the kernel, building
-	  with the "-O3" compiler flag for best performance and most
-	  helpful compile-time warnings.
-
 config CC_OPTIMIZE_FOR_PERFORMANCE
 	bool "Optimize for performance (-O2)"
 	help
@@ -1440,20 +1425,6 @@
         default "error" if WERROR
         default "warn"
 
-config OPTIMIZE_INLINING
-	bool "Allow gcc to uninline functions marked 'inline'"
-	help
-	  This option determines if the kernel forces gcc to inline the functions
-	  developers have marked 'inline'. Doing so takes away freedom from gcc to
-	  do what it thinks is best, which is desirable for the gcc 3.x series of
-	  compilers. The gcc 4.x series have a rewritten inlining algorithm and
-	  enabling this option will generate a smaller kernel there. Hopefully
-	  this algorithm is so good that allowing gcc 4.x and above to make the
-	  decision will become the default in the future. Until then this option
-	  is there to test gcc for this.
-
-	  If unsure, say N.
-
 config SYSCTL
 	bool
 
@@ -1496,7 +1467,7 @@
 
 # interpreter that classic socket filters depend on
 config BPF
-	bool "BFP Filter"
+	bool
 	select CRYPTO_LIB_SHA1
 
 menuconfig EXPERT
Index: init/do_mounts.c
===================================================================
--- init/do_mounts.c	(revision 55864)
+++ init/do_mounts.c	(revision 55863)
@@ -62,11 +62,7 @@
 
 static int __init root_dev_setup(char *line)
 {
-#ifdef CONFIG_ARCH_MVEBU
-	strcpy(saved_root_name, "/dev/ubiblock0_0");
-#else
- 	strscpy(saved_root_name, line, sizeof(saved_root_name));
-#endif
+	strscpy(saved_root_name, line, sizeof(saved_root_name));
 	return 1;
 }
 
@@ -117,11 +113,7 @@
 static char * __initdata root_fs_names;
 static int __init fs_names_setup(char *str)
 {
-#ifdef CONFIG_ARCH_MVEBU	
-	root_fs_names = "squashfs";
-#else
 	root_fs_names = str;
-#endif
 	return 1;
 }
 
@@ -190,7 +182,7 @@
 	return ret;
 }
 
-int __init mount_root_generic(char *name, char *pretty_name, int flags)
+void __init mount_root_generic(char *name, char *pretty_name, int flags)
 {
 	struct page *page = alloc_page(GFP_KERNEL);
 	char *fs_names = page_address(page);
@@ -218,9 +210,6 @@
 			case -EINVAL:
 				continue;
 		}
-#ifdef HAVE_X86
-		return -1;
-#else
 	        /*
 		 * Allow the user to distinguish between failed sys_open
 		 * and bad superblock on root device.
@@ -243,7 +232,6 @@
 		}
 
 		panic("VFS: Unable to mount root fs on %s", b);
-#endif
 	}
 	if (!(flags & SB_RDONLY)) {
 		flags |= SB_RDONLY;
@@ -250,9 +238,6 @@
 		goto retry;
 	}
 
-#ifdef HAVE_X86
-		return -1;
-#else
 	printk("List of all partitions:\n");
 	printk_all_partitions();
 	printk("No filesystem could mount root, tried: ");
@@ -260,10 +245,8 @@
 		printk(" %s", p);
 	printk("\n");
 	panic("VFS: Unable to mount root fs on %s", b);
-#endif
 out:
 	put_page(page);
-	return 0;
 }
 
 #ifdef CONFIG_MTD_ROOTFS_ROOT_DEV
@@ -409,13 +392,13 @@
 }
 
 #ifdef CONFIG_BLOCK
-static int __init mount_block_root(char *root_device_name)
+static void __init mount_block_root(char *root_device_name)
 {
 	int err = create_dev("/dev/root", ROOT_DEV);
 
 	if (err < 0)
 		pr_emerg("Failed to create /dev/root: %d\n", err);
-	return mount_root_generic("/dev/root", root_device_name, root_mountflags);
+	mount_root_generic("/dev/root", root_device_name, root_mountflags);
 }
 #else
 static inline void mount_block_root(char *root_device_name)
@@ -423,7 +406,7 @@
 }
 #endif /* CONFIG_BLOCK */
 
-int __init mount_root(char *root_device_name)
+void __init mount_root(char *root_device_name)
 {
 #ifdef CONFIG_MTD_ROOTFS_ROOT_DEV
 	if (!mount_ubi_rootfs())
@@ -438,7 +421,7 @@
 		mount_cifs_root();
 		break;
 	case Root_Generic:
-		return mount_root_generic(root_device_name, root_device_name,
+		mount_root_generic(root_device_name, root_device_name,
 				   root_mountflags);
 		break;
 	case 0:
@@ -447,38 +430,11 @@
 			break;
 		fallthrough;
 	default:
-		return mount_block_root(root_device_name);
+		mount_block_root(root_device_name);
 		break;
 	}
-	return 0;
 }
 
-#ifdef CONFIG_X86
-char * __initdata root_list[]={
-	"/dev/hda2",
-	"/dev/hdb2",
-	"/dev/hdc2",
-	"/dev/hdd2",
-	"/dev/sda2",
-	"/dev/sdb2",
-	"/dev/sdc2",
-	"/dev/sdd2",
-	"/dev/sde2",
-	"/dev/sdf2",
-	"/dev/sdg2",
-	"/dev/sdh2",
-	"/dev/sdi2",
-	"/dev/sr0", 
-	"/dev/mmcblk0p2",
-	"/dev/nvme0n1p2",
-	"/dev/nvme1n1p2",
-	"/dev/nvme2n1p2",
-	"/dev/nvme3n1p2",
-	"/dev/nvme4n1p2",
-	"/dev/nvme5n1p2",
-	};
-#endif
-
 /* wait for any asynchronous scanning to complete */
 static void __init wait_for_root(char *root_device_name)
 {
@@ -491,25 +447,6 @@
 
 	end = ktime_add_ms(ktime_get_raw(), root_wait);
 
-#ifdef HAVE_X86
-	while (!driver_probe_done())
-	{
-		msleep(5);
-		if (root_wait > 0 && ktime_after(ktime_get_raw(), end))
-			break;
-	} 
-	while (1)
-	{
-		int i;
-		for (i=0;i<ARRAY_SIZE(root_list);i++) {
-		    if (early_lookup_bdev(root_device_name, &ROOT_DEV)==0)
-			goto out;
-		}
-		msleep(5);
-		if (root_wait > 0 && ktime_after(ktime_get_raw(), end))
-			break;
-	}
-#else
 	while (!driver_probe_done() ||
 	       early_lookup_bdev(root_device_name, &ROOT_DEV) < 0) {
 		msleep(5);
@@ -516,8 +453,7 @@
 		if (root_wait > 0 && ktime_after(ktime_get_raw(), end))
 			break;
 	}
-#endif
-	out:;
+
 	async_synchronize_full();
 
 }
@@ -554,9 +490,6 @@
  */
 void __init prepare_namespace(void)
 {
-#ifdef HAVE_X86
-	int i;
-#endif
 	if (root_delay) {
 		printk(KERN_INFO "Waiting %d sec before mounting root device...\n",
 		       root_delay);
@@ -573,18 +506,6 @@
 	wait_for_device_probe();
 
 	md_run_setup();
-#ifdef HAVE_X86
-	if (root_wait)
-		wait_for_root(saved_root_name);
-	for (i=0;i<ARRAY_SIZE(root_list);i++)
-	    ROOT_DEV = parse_root_device(root_list[i]);
-	    if (initrd_load(root_list[i]))
-		goto out;
-	    if (!mount_root(root_list[i])) {
-		    saved_root_name = root_list[i];
-		    goto out;
-	    }
-#else
 
 	if (saved_root_name[0])
 		ROOT_DEV = parse_root_device(saved_root_name);
@@ -594,9 +515,7 @@
 
 	if (root_wait)
 		wait_for_root(saved_root_name);
-
 	mount_root(saved_root_name);
-#endif
 out:
 	devtmpfs_mount();
 	init_mount(".", "/", NULL, MS_MOVE, NULL);
